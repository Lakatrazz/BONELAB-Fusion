// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;

namespace Epic.OnlineServices.Achievements
{
	public sealed partial class AchievementsInterface : Handle
	{
		public AchievementsInterface()
		{
		}

		public AchievementsInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// Timestamp value representing an undefined UnlockTime for <see cref="PlayerAchievement" /> and <see cref="UnlockedAchievement" />
		/// </summary>
		public const int ACHIEVEMENT_UNLOCKTIME_UNDEFINED = -1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifyAchievementsUnlockedV2" /> API.
		/// </summary>
		public const int ADDNOTIFYACHIEVEMENTSUNLOCKEDV2_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifyAchievementsUnlocked" /> API.
		/// </summary>
		public const int ADDNOTIFYACHIEVEMENTSUNLOCKED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyAchievementDefinitionV2ByAchievementIdOptions" /> struct.
		/// </summary>
		public const int COPYACHIEVEMENTDEFINITIONV2BYACHIEVEMENTID_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="CopyAchievementDefinitionByIndexOptions" /> struct.
		/// </summary>
		public const int COPYACHIEVEMENTDEFINITIONV2BYINDEX_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="CopyAchievementDefinitionByAchievementIdOptions" /> struct.
		/// </summary>
		public const int COPYDEFINITIONBYACHIEVEMENTID_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyAchievementDefinitionByIndexOptions" /> struct.
		/// </summary>
		public const int COPYDEFINITIONBYINDEX_API_LATEST = 1;
		/// <summary>
		/// DEPRECATED! Use <see cref="COPYACHIEVEMENTDEFINITIONV2BYACHIEVEMENTID_API_LATEST" /> instead.
		/// </summary>
		public const int COPYDEFINITIONV2BYACHIEVEMENTID_API_LATEST = COPYACHIEVEMENTDEFINITIONV2BYACHIEVEMENTID_API_LATEST;
		/// <summary>
		/// DEPRECATED! Use <see cref="COPYACHIEVEMENTDEFINITIONV2BYINDEX_API_LATEST" /> instead.
		/// </summary>
		public const int COPYDEFINITIONV2BYINDEX_API_LATEST = COPYACHIEVEMENTDEFINITIONV2BYINDEX_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="CopyPlayerAchievementByAchievementIdOptions" /> struct.
		/// </summary>
		public const int COPYPLAYERACHIEVEMENTBYACHIEVEMENTID_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="CopyPlayerAchievementByIndexOptions" /> struct.
		/// </summary>
		public const int COPYPLAYERACHIEVEMENTBYINDEX_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="CopyUnlockedAchievementByAchievementIdOptions" /> struct.
		/// </summary>
		public const int COPYUNLOCKEDACHIEVEMENTBYACHIEVEMENTID_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyUnlockedAchievementByIndexOptions" /> struct.
		/// </summary>
		public const int COPYUNLOCKEDACHIEVEMENTBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="DefinitionV2" /> struct.
		/// </summary>
		public const int DEFINITIONV2_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="Definition" /> struct.
		/// </summary>
		public const int DEFINITION_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetAchievementDefinitionCount" /> API.
		/// </summary>
		public const int GETACHIEVEMENTDEFINITIONCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetPlayerAchievementCount" /> API.
		/// </summary>
		public const int GETPLAYERACHIEVEMENTCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetUnlockedAchievementCount" /> API.
		/// </summary>
		public const int GETUNLOCKEDACHIEVEMENTCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="PlayerAchievement" /> struct.
		/// </summary>
		public const int PLAYERACHIEVEMENT_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="PlayerStatInfo" /> struct.
		/// </summary>
		public const int PLAYERSTATINFO_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="QueryDefinitions" /> struct.
		/// </summary>
		public const int QUERYDEFINITIONS_API_LATEST = 3;
		/// <summary>
		/// The most recent version of the <see cref="QueryPlayerAchievements" /> struct.
		/// </summary>
		public const int QUERYPLAYERACHIEVEMENTS_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="StatThresholds" /> struct.
		/// </summary>
		public const int STATTHRESHOLDS_API_LATEST = 1;
		/// <summary>
		/// DEPRECATED! Use <see cref="STATTHRESHOLDS_API_LATEST" /> instead.
		/// </summary>
		public const int STATTHRESHOLD_API_LATEST = STATTHRESHOLDS_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="UnlockAchievements" /> struct.
		/// </summary>
		public const int UNLOCKACHIEVEMENTS_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="UnlockedAchievement" /> struct.
		/// </summary>
		public const int UNLOCKEDACHIEVEMENT_API_LATEST = 1;

		/// <summary>
		/// DEPRECATED! Use <see cref="AddNotifyAchievementsUnlockedV2" /> instead.
		/// 
		/// Register to receive achievement unlocked notifications.
		/// If the returned NotificationId is valid, you must call <see cref="RemoveNotifyAchievementsUnlocked" /> when you no longer wish to have your NotificationHandler called.
		/// <see cref="RemoveNotifyAchievementsUnlocked" />
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the achievement unlocked notification
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="notificationFn">
		/// A callback that is fired when an achievement unlocked notification for a user has been received
		/// </param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyAchievementsUnlocked(ref AddNotifyAchievementsUnlockedOptions options, object clientData, OnAchievementsUnlockedCallback notificationFn)
		{
			if (notificationFn == null)
			{
				throw new ArgumentNullException("notificationFn");
			}

			var optionsInternal = default(AddNotifyAchievementsUnlockedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, notificationFn);

			var callResult = Bindings.EOS_Achievements_AddNotifyAchievementsUnlocked(InnerHandle, ref optionsInternal, clientDataPointer, OnAchievementsUnlockedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Register to receive achievement unlocked notifications.
		/// If the returned NotificationId is valid, you must call <see cref="RemoveNotifyAchievementsUnlocked" /> when you no longer wish to have your NotificationHandler called.
		/// <see cref="RemoveNotifyAchievementsUnlocked" />
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the achievement unlocked notification
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="notificationFn">
		/// A callback that is fired when an achievement unlocked notification for a user has been received
		/// </param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyAchievementsUnlockedV2(ref AddNotifyAchievementsUnlockedV2Options options, object clientData, OnAchievementsUnlockedCallbackV2 notificationFn)
		{
			if (notificationFn == null)
			{
				throw new ArgumentNullException("notificationFn");
			}

			var optionsInternal = default(AddNotifyAchievementsUnlockedV2OptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, notificationFn);

			var callResult = Bindings.EOS_Achievements_AddNotifyAchievementsUnlockedV2(InnerHandle, ref optionsInternal, clientDataPointer, OnAchievementsUnlockedCallbackV2InternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// DEPRECATED! Use <see cref="CopyAchievementDefinitionV2ByAchievementId" /> instead.
		/// 
		/// Fetches an achievement definition from a given achievement ID.
		/// <see cref="Release" />
		/// <see cref="CopyAchievementDefinitionV2ByAchievementId" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the achievement ID being accessed
		/// </param>
		/// <param name="outDefinition">
		/// The achievement definition for the given achievement ID, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutDefinition
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the achievement definition is not found
		/// </returns>
		public Result CopyAchievementDefinitionByAchievementId(ref CopyAchievementDefinitionByAchievementIdOptions options, out Definition? outDefinition)
		{
			var optionsInternal = default(CopyAchievementDefinitionByAchievementIdOptionsInternal);
			optionsInternal.Set(ref options);

			var outDefinitionPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Achievements_CopyAchievementDefinitionByAchievementId(InnerHandle, ref optionsInternal, out outDefinitionPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<DefinitionInternal, Definition>(outDefinitionPointer, out outDefinition);
			if (outDefinitionPointer != IntPtr.Zero)
			{
				Bindings.EOS_Achievements_Definition_Release(outDefinitionPointer);
			}

			return callResult;
		}

		/// <summary>
		/// DEPRECATED! Use <see cref="CopyAchievementDefinitionV2ByIndex" /> instead.
		/// 
		/// Fetches an achievement definition from a given index.
		/// <see cref="CopyAchievementDefinitionV2ByIndex" />
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the index being accessed
		/// </param>
		/// <param name="outDefinition">
		/// The achievement definition for the given index, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutDefinition
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the achievement definition is not found
		/// </returns>
		public Result CopyAchievementDefinitionByIndex(ref CopyAchievementDefinitionByIndexOptions options, out Definition? outDefinition)
		{
			var optionsInternal = default(CopyAchievementDefinitionByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outDefinitionPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Achievements_CopyAchievementDefinitionByIndex(InnerHandle, ref optionsInternal, out outDefinitionPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<DefinitionInternal, Definition>(outDefinitionPointer, out outDefinition);
			if (outDefinitionPointer != IntPtr.Zero)
			{
				Bindings.EOS_Achievements_Definition_Release(outDefinitionPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches an achievement definition from a given achievement ID.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the achievement ID being accessed
		/// </param>
		/// <param name="outDefinition">
		/// The achievement definition for the given achievement ID, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutDefinition
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the achievement definition is not found
		/// <see cref="Result.InvalidProductUserID" /> if any of the userid options are incorrect
		/// </returns>
		public Result CopyAchievementDefinitionV2ByAchievementId(ref CopyAchievementDefinitionV2ByAchievementIdOptions options, out DefinitionV2? outDefinition)
		{
			var optionsInternal = default(CopyAchievementDefinitionV2ByAchievementIdOptionsInternal);
			optionsInternal.Set(ref options);

			var outDefinitionPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId(InnerHandle, ref optionsInternal, out outDefinitionPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<DefinitionV2Internal, DefinitionV2>(outDefinitionPointer, out outDefinition);
			if (outDefinitionPointer != IntPtr.Zero)
			{
				Bindings.EOS_Achievements_DefinitionV2_Release(outDefinitionPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches an achievement definition from a given index.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the index being accessed
		/// </param>
		/// <param name="outDefinition">
		/// The achievement definition for the given index, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutDefinition
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the achievement definition is not found
		/// <see cref="Result.InvalidProductUserID" /> if any of the userid options are incorrect
		/// </returns>
		public Result CopyAchievementDefinitionV2ByIndex(ref CopyAchievementDefinitionV2ByIndexOptions options, out DefinitionV2? outDefinition)
		{
			var optionsInternal = default(CopyAchievementDefinitionV2ByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outDefinitionPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Achievements_CopyAchievementDefinitionV2ByIndex(InnerHandle, ref optionsInternal, out outDefinitionPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<DefinitionV2Internal, DefinitionV2>(outDefinitionPointer, out outDefinition);
			if (outDefinitionPointer != IntPtr.Zero)
			{
				Bindings.EOS_Achievements_DefinitionV2_Release(outDefinitionPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches a player achievement from a given achievement ID.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the Product User ID and achievement ID being accessed
		/// </param>
		/// <param name="outAchievement">
		/// The player achievement data for the given achievement ID, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutAchievement
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the player achievement is not found
		/// <see cref="Result.InvalidProductUserID" /> if you pass an invalid user ID
		/// </returns>
		public Result CopyPlayerAchievementByAchievementId(ref CopyPlayerAchievementByAchievementIdOptions options, out PlayerAchievement? outAchievement)
		{
			var optionsInternal = default(CopyPlayerAchievementByAchievementIdOptionsInternal);
			optionsInternal.Set(ref options);

			var outAchievementPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Achievements_CopyPlayerAchievementByAchievementId(InnerHandle, ref optionsInternal, out outAchievementPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<PlayerAchievementInternal, PlayerAchievement>(outAchievementPointer, out outAchievement);
			if (outAchievementPointer != IntPtr.Zero)
			{
				Bindings.EOS_Achievements_PlayerAchievement_Release(outAchievementPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches a player achievement from a given index.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the Product User ID and index being accessed
		/// </param>
		/// <param name="outAchievement">
		/// The player achievement data for the given index, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutAchievement
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the player achievement is not found
		/// <see cref="Result.InvalidProductUserID" /> if you pass an invalid user ID
		/// </returns>
		public Result CopyPlayerAchievementByIndex(ref CopyPlayerAchievementByIndexOptions options, out PlayerAchievement? outAchievement)
		{
			var optionsInternal = default(CopyPlayerAchievementByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outAchievementPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Achievements_CopyPlayerAchievementByIndex(InnerHandle, ref optionsInternal, out outAchievementPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<PlayerAchievementInternal, PlayerAchievement>(outAchievementPointer, out outAchievement);
			if (outAchievementPointer != IntPtr.Zero)
			{
				Bindings.EOS_Achievements_PlayerAchievement_Release(outAchievementPointer);
			}

			return callResult;
		}

		/// <summary>
		/// DEPRECATED! Use <see cref="CopyPlayerAchievementByAchievementId" /> instead.
		/// 
		/// Fetches an unlocked achievement from a given achievement ID.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the Product User ID and achievement ID being accessed
		/// </param>
		/// <param name="outAchievement">
		/// The unlocked achievement data for the given achievement ID, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutAchievement
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the unlocked achievement is not found
		/// </returns>
		public Result CopyUnlockedAchievementByAchievementId(ref CopyUnlockedAchievementByAchievementIdOptions options, out UnlockedAchievement? outAchievement)
		{
			var optionsInternal = default(CopyUnlockedAchievementByAchievementIdOptionsInternal);
			optionsInternal.Set(ref options);

			var outAchievementPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Achievements_CopyUnlockedAchievementByAchievementId(InnerHandle, ref optionsInternal, out outAchievementPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<UnlockedAchievementInternal, UnlockedAchievement>(outAchievementPointer, out outAchievement);
			if (outAchievementPointer != IntPtr.Zero)
			{
				Bindings.EOS_Achievements_UnlockedAchievement_Release(outAchievementPointer);
			}

			return callResult;
		}

		/// <summary>
		/// DEPRECATED! Use <see cref="CopyPlayerAchievementByAchievementId" /> instead.
		/// 
		/// Fetches an unlocked achievement from a given index.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the Product User ID and index being accessed
		/// </param>
		/// <param name="outAchievement">
		/// The unlocked achievement data for the given index, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutAchievement
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the unlocked achievement is not found
		/// </returns>
		public Result CopyUnlockedAchievementByIndex(ref CopyUnlockedAchievementByIndexOptions options, out UnlockedAchievement? outAchievement)
		{
			var optionsInternal = default(CopyUnlockedAchievementByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outAchievementPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Achievements_CopyUnlockedAchievementByIndex(InnerHandle, ref optionsInternal, out outAchievementPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<UnlockedAchievementInternal, UnlockedAchievement>(outAchievementPointer, out outAchievement);
			if (outAchievementPointer != IntPtr.Zero)
			{
				Bindings.EOS_Achievements_UnlockedAchievement_Release(outAchievementPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetch the number of achievement definitions that are cached locally.
		/// <see cref="CopyAchievementDefinitionByIndex" />
		/// </summary>
		/// <param name="options">
		/// The Options associated with retrieving the achievement definition count
		/// </param>
		/// <returns>
		/// Number of achievement definitions or 0 if there is an error
		/// </returns>
		public uint GetAchievementDefinitionCount(ref GetAchievementDefinitionCountOptions options)
		{
			var optionsInternal = default(GetAchievementDefinitionCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Achievements_GetAchievementDefinitionCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Fetch the number of player achievements that are cached locally.
		/// <see cref="CopyPlayerAchievementByIndex" />
		/// </summary>
		/// <param name="options">
		/// The Options associated with retrieving the player achievement count
		/// </param>
		/// <returns>
		/// Number of player achievements or 0 if there is an error
		/// </returns>
		public uint GetPlayerAchievementCount(ref GetPlayerAchievementCountOptions options)
		{
			var optionsInternal = default(GetPlayerAchievementCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Achievements_GetPlayerAchievementCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// DEPRECATED! Use <see cref="GetPlayerAchievementCount" />, <see cref="CopyPlayerAchievementByIndex" /> and filter for unlocked instead.
		/// 
		/// Fetch the number of unlocked achievements that are cached locally.
		/// <see cref="CopyUnlockedAchievementByIndex" />
		/// </summary>
		/// <param name="options">
		/// The Options associated with retrieving the unlocked achievement count
		/// </param>
		/// <returns>
		/// Number of unlocked achievements or 0 if there is an error
		/// </returns>
		public uint GetUnlockedAchievementCount(ref GetUnlockedAchievementCountOptions options)
		{
			var optionsInternal = default(GetUnlockedAchievementCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Achievements_GetUnlockedAchievementCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Query for a list of definitions for all existing achievements, including localized text, icon IDs and whether an achievement is hidden.
		/// When the Social Overlay is enabled then this will be called automatically. The Social Overlay is enabled by default (see <see cref="Platform.PlatformFlags.DisableSocialOverlay" />).
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the application whose achievement definitions we're retrieving.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// This function is called when the query definitions operation completes.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// </returns>
		public void QueryDefinitions(ref QueryDefinitionsOptions options, object clientData, OnQueryDefinitionsCompleteCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryDefinitionsOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Achievements_QueryDefinitions(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryDefinitionsCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Query for a list of achievements for a specific player, including progress towards completion for each achievement.
		/// Note: By default, this query will not return locked hidden achievements. To return all achievements, call <see cref="QueryDefinitions" /> first.
		/// When the Social Overlay is enabled then this will be called automatically. The Social Overlay is enabled by default (see <see cref="Platform.PlatformFlags.DisableSocialOverlay" />).
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the player whose achievements we're retrieving.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// This function is called when the query player achievements operation completes.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation completes successfully
		/// <see cref="Result.InvalidProductUserID" /> if any of the userid options are incorrect
		/// <see cref="Result.InvalidParameters" /> if any of the other options are incorrect
		/// </returns>
		public void QueryPlayerAchievements(ref QueryPlayerAchievementsOptions options, object clientData, OnQueryPlayerAchievementsCompleteCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryPlayerAchievementsOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Achievements_QueryPlayerAchievements(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryPlayerAchievementsCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Unregister from receiving achievement unlocked notifications.
		/// <see cref="AddNotifyAchievementsUnlocked" />
		/// </summary>
		/// <param name="inId">
		/// Handle representing the registered callback
		/// </param>
		public void RemoveNotifyAchievementsUnlocked(ulong inId)
		{
			Bindings.EOS_Achievements_RemoveNotifyAchievementsUnlocked(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unlocks a number of achievements for a specific player.
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the achievements and the player whose achievements we're unlocking.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// This function is called when the unlock achievements operation completes.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// </returns>
		public void UnlockAchievements(ref UnlockAchievementsOptions options, object clientData, OnUnlockAchievementsCompleteCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(UnlockAchievementsOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Achievements_UnlockAchievements(InnerHandle, ref optionsInternal, clientDataPointer, OnUnlockAchievementsCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}
	}
}
