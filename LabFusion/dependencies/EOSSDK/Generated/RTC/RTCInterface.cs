// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;

namespace Epic.OnlineServices.RTC
{
	public sealed partial class RTCInterface : Handle
	{
		public RTCInterface()
		{
		}

		public RTCInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyDisconnected" /> API.
		/// </summary>
		public const int ADDNOTIFYDISCONNECTED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifyParticipantStatusChanged" /> API.
		/// </summary>
		public const int ADDNOTIFYPARTICIPANTSTATUSCHANGED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifyRoomStatisticsUpdated" /> API.
		/// </summary>
		public const int ADDNOTIFYROOMSTATISTICSUPDATED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="BlockParticipant" /> API.
		/// </summary>
		public const int BLOCKPARTICIPANT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="JoinRoom" /> API.
		/// </summary>
		public const int JOINROOM_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="LeaveRoom" /> API.
		/// </summary>
		public const int LEAVEROOM_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="Option" /> struct.
		/// </summary>
		public const int OPTION_API_LATEST = 1;
		/// <summary>
		/// The maximum size of the Key <see cref="Utf8String" /> in the <see cref="Option" /> struct.
		/// </summary>
		public const int OPTION_KEY_MAXCHARCOUNT = 256;
		/// <summary>
		/// The maximum size of the Value <see cref="Utf8String" /> in the <see cref="Option" /> struct.
		/// </summary>
		public const int OPTION_VALUE_MAXCHARCOUNT = 256;
		/// <summary>
		/// The most recent version of the <see cref="ParticipantMetadata" /> struct.
		/// </summary>
		public const int PARTICIPANTMETADATA_API_LATEST = 1;
		/// <summary>
		/// The maximum size of the Key <see cref="Utf8String" /> in the <see cref="ParticipantMetadata" /> struct.
		/// </summary>
		public const int PARTICIPANTMETADATA_KEY_MAXCHARCOUNT = 256;
		/// <summary>
		/// The maximum size of the Value <see cref="Utf8String" /> in the <see cref="ParticipantMetadata" /> struct.
		/// </summary>
		public const int PARTICIPANTMETADATA_VALUE_MAXCHARCOUNT = 256;
		/// <summary>
		/// The most recent version of the <see cref="SetRoomSetting" /> API.
		/// </summary>
		public const int SETROOMSETTING_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SetSetting" /> API.
		/// </summary>
		public const int SETSETTING_API_LATEST = 1;

		/// <summary>
		/// Register to receive notifications when disconnected from the room. If the returned NotificationId is valid, you must call
		/// <see cref="RemoveNotifyDisconnected" /> when you no longer wish to have your CompletionDelegate called.
		/// 
		/// This function will always return <see cref="Common.INVALID_NOTIFICATIONID" /> when used with lobby RTC room. To be notified of the connection
		/// status of a Lobby-managed RTC room, use the <see cref="Lobby.LobbyInterface.AddNotifyRTCRoomConnectionChanged" /> function instead.
		/// <see cref="Common.INVALID_NOTIFICATIONID" />
		/// <see cref="RemoveNotifyDisconnected" />
		/// </summary>
		/// <param name="clientData">
		/// Arbitrary data that is passed back in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// The callback to be fired when a participant is disconnected from the room
		/// </param>
		/// <returns>
		/// Notification ID representing the registered callback if successful, an invalid NotificationId if not
		/// </returns>
		public ulong AddNotifyDisconnected(ref AddNotifyDisconnectedOptions options, object clientData, OnDisconnectedCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(AddNotifyDisconnectedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			var callResult = Bindings.EOS_RTC_AddNotifyDisconnected(InnerHandle, ref optionsInternal, clientDataPointer, OnDisconnectedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Register to receive notifications when a participant's status changes (e.g: join or leave the room), or when the participant is added or removed
		/// from an applicable block list (e.g: Epic block list and/or current platform's block list).
		/// If the returned NotificationId is valid, you must call <see cref="RemoveNotifyParticipantStatusChanged" /> when you no longer wish to have your CompletionDelegate called.
		/// 
		/// If you register to this notification before joining a room, you will receive a notification for every member already in the room when you join said room.
		/// This allows you to know who is already in the room when you join.
		/// 
		/// To be used effectively with a Lobby-managed RTC room, this should be registered during the <see cref="Lobby.LobbyInterface.CreateLobby" /> or <see cref="Lobby.LobbyInterface.JoinLobby" /> completion
		/// callbacks when the ResultCode is <see cref="Result.Success" />. If this notification is registered after that point, it is possible to miss notifications for
		/// already-existing room participants.
		/// 
		/// You can use this notification to detect internal automatic RTC blocks due to block lists.
		/// When a participant joins a room and while the system resolves the block list status of said participant, the participant is set to blocked and you'll receive
		/// a notification with ParticipantStatus set to <see cref="RTCParticipantStatus.Joined" /> and bParticipantInBlocklist set to <see langword="true" />.
		/// Once the block list status is resolved, if the player is not in any applicable block list(s), it is then unblocked and a new notification is sent with
		/// ParticipantStatus set to <see cref="RTCParticipantStatus.Joined" /> and bParticipantInBlocklist set to <see langword="false" />.
		/// This notification is also raised when the local user joins the room, but NOT when the local user leaves the room.
		/// <see cref="Common.INVALID_NOTIFICATIONID" />
		/// <see cref="RemoveNotifyParticipantStatusChanged" />
		/// </summary>
		/// <param name="clientData">
		/// Arbitrary data that is passed back in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// The callback to be fired when a participant changes status
		/// </param>
		/// <returns>
		/// Notification ID representing the registered callback if successful, an invalid NotificationId if not
		/// </returns>
		public ulong AddNotifyParticipantStatusChanged(ref AddNotifyParticipantStatusChangedOptions options, object clientData, OnParticipantStatusChangedCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(AddNotifyParticipantStatusChangedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			var callResult = Bindings.EOS_RTC_AddNotifyParticipantStatusChanged(InnerHandle, ref optionsInternal, clientDataPointer, OnParticipantStatusChangedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Register to receive notifications to receiving periodical statistics update. If the returned NotificationId is valid, you must call
		/// <see cref="RemoveNotifyRoomStatisticsUpdated" /> when you no longer wish to have your StatisticsUpdateHandler called.
		/// <see cref="Common.INVALID_NOTIFICATIONID" />
		/// <see cref="RemoveNotifyRoomStatisticsUpdated" />
		/// </summary>
		/// <param name="options">
		/// structure containing the parameters for the operation
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back in the StatisticsUpdateHandler
		/// </param>
		/// <param name="statisticsUpdateHandler">
		/// The callback to be fired when a statistics updated.
		/// </param>
		/// <returns>
		/// Notification ID representing the registered callback if successful, an invalid NotificationId if not
		/// </returns>
		public ulong AddNotifyRoomStatisticsUpdated(ref AddNotifyRoomStatisticsUpdatedOptions options, object clientData, OnRoomStatisticsUpdatedCallback statisticsUpdateHandler)
		{
			if (statisticsUpdateHandler == null)
			{
				throw new ArgumentNullException("statisticsUpdateHandler");
			}

			var optionsInternal = default(AddNotifyRoomStatisticsUpdatedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, statisticsUpdateHandler);

			var callResult = Bindings.EOS_RTC_AddNotifyRoomStatisticsUpdated(InnerHandle, ref optionsInternal, clientDataPointer, OnRoomStatisticsUpdatedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Use this function to block a participant already connected to the room. After blocking them no media will be sent or received between
		/// that user and the local user. This method can be used after receiving the OnParticipantStatusChanged notification.
		/// </summary>
		/// <param name="options">
		/// structure containing the parameters for the operation.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation succeeded
		/// <see cref="Result.InvalidParameters" /> if any of the parameters are incorrect
		/// <see cref="Result.NotFound" /> if either the local user or specified participant are not in the specified room
		/// <see cref="Result.UserIsInBlocklist" /> The user is in one of the platform's applicable block lists and thus an RTC unblock is not allowed.
		/// </returns>
		public void BlockParticipant(ref BlockParticipantOptions options, object clientData, OnBlockParticipantCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(BlockParticipantOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_RTC_BlockParticipant(InnerHandle, ref optionsInternal, clientDataPointer, OnBlockParticipantCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Get a handle to the Audio interface
		/// eos_rtc_audio.h
		/// eos_rtc_audio_types.h
		/// </summary>
		/// <returns>
		/// <see cref="RTCAudio.RTCAudioInterface" /> handle
		/// </returns>
		public RTCAudio.RTCAudioInterface GetAudioInterface()
		{
			var callResult = Bindings.EOS_RTC_GetAudioInterface(InnerHandle);

			RTCAudio.RTCAudioInterface callResultReturn;
			Helper.Get(callResult, out callResultReturn);
			return callResultReturn;
		}

		/// <summary>
		/// Get a handle to the Data interface
		/// eos_rtc_data.h
		/// eos_rtc_data_types.h
		/// </summary>
		/// <returns>
		/// <see cref="RTCData.RTCDataInterface" /> handle
		/// </returns>
		public RTCData.RTCDataInterface GetDataInterface()
		{
			var callResult = Bindings.EOS_RTC_GetDataInterface(InnerHandle);

			RTCData.RTCDataInterface callResultReturn;
			Helper.Get(callResult, out callResultReturn);
			return callResultReturn;
		}

		/// <summary>
		/// Use this function to join a room.
		/// 
		/// This function does not need to called for the Lobby RTC Room system; doing so will return <see cref="Result.AccessDenied" />. The lobby system will
		/// automatically join and leave RTC Rooms for all lobbies that have RTC rooms enabled.
		/// </summary>
		/// <param name="options">
		/// structure containing the parameters for the operation.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void JoinRoom(ref JoinRoomOptions options, object clientData, OnJoinRoomCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(JoinRoomOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_RTC_JoinRoom(InnerHandle, ref optionsInternal, clientDataPointer, OnJoinRoomCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Use this function to leave a room and clean up all the resources associated with it. This function has to always be called when the
		/// room is abandoned even if the user is already disconnected for other reasons.
		/// 
		/// This function does not need to called for the Lobby RTC Room system; doing so will return <see cref="Result.AccessDenied" />. The lobby system will
		/// automatically join and leave RTC Rooms for all lobbies that have RTC rooms enabled.
		/// </summary>
		/// <param name="options">
		/// structure containing the parameters for the operation.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation succeeded
		/// <see cref="Result.InvalidParameters" /> if any of the parameters are incorrect
		/// <see cref="Result.NotFound" /> if not in the specified room
		/// </returns>
		public void LeaveRoom(ref LeaveRoomOptions options, object clientData, OnLeaveRoomCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(LeaveRoomOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_RTC_LeaveRoom(InnerHandle, ref optionsInternal, clientDataPointer, OnLeaveRoomCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Unregister a previously bound notification handler from receiving room disconnection notifications
		/// </summary>
		/// <param name="notificationId">
		/// The Notification ID representing the registered callback
		/// </param>
		public void RemoveNotifyDisconnected(ulong notificationId)
		{
			Bindings.EOS_RTC_RemoveNotifyDisconnected(InnerHandle, notificationId);

			Helper.RemoveCallbackByNotificationId(notificationId);
		}

		/// <summary>
		/// Unregister a previously bound notification handler from receiving participant status change notifications
		/// </summary>
		/// <param name="notificationId">
		/// The Notification ID representing the registered callback
		/// </param>
		public void RemoveNotifyParticipantStatusChanged(ulong notificationId)
		{
			Bindings.EOS_RTC_RemoveNotifyParticipantStatusChanged(InnerHandle, notificationId);

			Helper.RemoveCallbackByNotificationId(notificationId);
		}

		/// <summary>
		/// Unregister a previously bound notification handler from receiving periodical statistics update notifications
		/// </summary>
		/// <param name="notificationId">
		/// The Notification ID representing the registered callback
		/// </param>
		public void RemoveNotifyRoomStatisticsUpdated(ulong notificationId)
		{
			Bindings.EOS_RTC_RemoveNotifyRoomStatisticsUpdated(InnerHandle, notificationId);

			Helper.RemoveCallbackByNotificationId(notificationId);
		}

		/// <summary>
		/// Use this function to control settings for the specific room.
		/// 
		/// The available settings are documented as part of <see cref="SetRoomSettingOptions" />.
		/// </summary>
		/// <param name="options">
		/// structure containing the parameters for the operation
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> when the setting is successfully set, <see cref="Result.NotFound" /> when the setting is unknown, <see cref="Result.InvalidParameters" /> when the value is invalid.
		/// </returns>
		public Result SetRoomSetting(ref SetRoomSettingOptions options)
		{
			var optionsInternal = default(SetRoomSettingOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_RTC_SetRoomSetting(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Use this function to control settings.
		/// 
		/// The available settings are documented as part of <see cref="SetSettingOptions" />.
		/// </summary>
		/// <param name="options">
		/// structure containing the parameters for the operation
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> when the setting is successfully set, <see cref="Result.NotFound" /> when the setting is unknown, <see cref="Result.InvalidParameters" /> when the value is invalid.
		/// </returns>
		public Result SetSetting(ref SetSettingOptions options)
		{
			var optionsInternal = default(SetSettingOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_RTC_SetSetting(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}
	}
}
