// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;
using System.Runtime.InteropServices;

namespace Epic.OnlineServices.AntiCheatCommon
{
	/// <summary>
	/// Input parameters for the <see cref="AntiCheatServer.AntiCheatServerInterface.LogPlayerTakeDamage" /> function.
	/// </summary>
	public struct LogPlayerTakeDamageOptions
	{
		/// <summary>
		/// Locally unique value used in RegisterClient/RegisterPeer
		/// </summary>
		public IntPtr VictimPlayerHandle { get; set; }

		/// <summary>
		/// Victim player character's world position as a 3D vector. This should be the center of the character.
		/// </summary>
		public Vec3f? VictimPlayerPosition { get; set; }

		/// <summary>
		/// Victim player camera's world rotation as a quaternion.
		/// </summary>
		public Quat? VictimPlayerViewRotation { get; set; }

		/// <summary>
		/// Locally unique value used in RegisterClient/RegisterPeer if applicable, otherwise 0.
		/// </summary>
		public IntPtr AttackerPlayerHandle { get; set; }

		/// <summary>
		/// Attacker player character's world position as a 3D vector if applicable, otherwise <see langword="null" />.
		/// </summary>
		public Vec3f? AttackerPlayerPosition { get; set; }

		/// <summary>
		/// Attacker player camera's world rotation as a quaternion if applicable, otherwise <see langword="null" />.
		/// </summary>
		public Quat? AttackerPlayerViewRotation { get; set; }

		/// <summary>
		/// True if the damage was applied instantly at the time of attack from the game
		/// simulation's perspective, otherwise <see langword="false" /> (simulated ballistics, arrow, etc).
		/// </summary>
		public bool IsHitscanAttack { get; set; }

		/// <summary>
		/// True if there is a visible line of sight between the attacker and the victim at the time
		/// that damage is being applied, <see langword="false" /> if there is an obstacle like a wall or terrain in
		/// the way. For some situations like melee or hitscan weapons this is trivially
		/// <see langword="true" />, for others like projectiles with simulated physics it may not be e.g. a player
		/// could fire a slow moving projectile and then move behind cover before it strikes.
		/// 
		/// This can be an estimate, or can simply be always set to <see langword="true" /> if it is not feasible
		/// to compute in your game.
		/// </summary>
		public bool HasLineOfSight { get; set; }

		/// <summary>
		/// True if this was a critical hit that causes extra damage (e.g. headshot)
		/// </summary>
		public bool IsCriticalHit { get; set; }

		/// <summary>
		/// Deprecated - use DamagePosition instead
		/// </summary>
		public uint HitBoneId_DEPRECATED { get; set; }

		/// <summary>
		/// Number of health points that the victim lost due to this damage event
		/// </summary>
		public float DamageTaken { get; set; }

		/// <summary>
		/// Number of health points that the victim has remaining after this damage event
		/// </summary>
		public float HealthRemaining { get; set; }

		/// <summary>
		/// Source of the damage event
		/// </summary>
		public AntiCheatCommonPlayerTakeDamageSource DamageSource { get; set; }

		/// <summary>
		/// Type of the damage being applied
		/// </summary>
		public AntiCheatCommonPlayerTakeDamageType DamageType { get; set; }

		/// <summary>
		/// Result of the damage for the victim, if any
		/// </summary>
		public AntiCheatCommonPlayerTakeDamageResult DamageResult { get; set; }

		/// <summary>
		/// PlayerUseWeaponData associated with this damage event if available, otherwise <see langword="null" />
		/// </summary>
		public LogPlayerUseWeaponData? PlayerUseWeaponData { get; set; }

		/// <summary>
		/// Time in milliseconds since the associated PlayerUseWeaponData event occurred if available, otherwise 0
		/// </summary>
		public uint TimeSincePlayerUseWeaponMs { get; set; }

		/// <summary>
		/// World position where damage hit the victim as a 3D vector if available, otherwise <see langword="null" />
		/// </summary>
		public Vec3f? DamagePosition { get; set; }

		/// <summary>
		/// Attacker player camera's world position as a 3D vector if applicable, otherwise <see langword="null" />
		/// </summary>
		public Vec3f? AttackerPlayerViewPosition { get; set; }
	}

	[StructLayout(LayoutKind.Sequential)]
	internal struct LogPlayerTakeDamageOptionsInternal : ISettable<LogPlayerTakeDamageOptions>
	{
		private int m_ApiVersion;
		private IntPtr m_VictimPlayerHandle;
		private IntPtr m_VictimPlayerPosition;
		private IntPtr m_VictimPlayerViewRotation;
		private IntPtr m_AttackerPlayerHandle;
		private IntPtr m_AttackerPlayerPosition;
		private IntPtr m_AttackerPlayerViewRotation;
		private int m_IsHitscanAttack;
		private int m_HasLineOfSight;
		private int m_IsCriticalHit;
		private uint m_HitBoneId_DEPRECATED;
		private float m_DamageTaken;
		private float m_HealthRemaining;
		private AntiCheatCommonPlayerTakeDamageSource m_DamageSource;
		private AntiCheatCommonPlayerTakeDamageType m_DamageType;
		private AntiCheatCommonPlayerTakeDamageResult m_DamageResult;
		private IntPtr m_PlayerUseWeaponData;
		private uint m_TimeSincePlayerUseWeaponMs;
		private IntPtr m_DamagePosition;
		private IntPtr m_AttackerPlayerViewPosition;

		public void Set(ref LogPlayerTakeDamageOptions other)
		{
			Dispose();

			m_ApiVersion = AntiCheatCommonInterface.LOGPLAYERTAKEDAMAGE_API_LATEST;
			m_VictimPlayerHandle = other.VictimPlayerHandle;
			Helper.Set<Vec3f, Vec3fInternal>(other.VictimPlayerPosition, ref m_VictimPlayerPosition);
			Helper.Set<Quat, QuatInternal>(other.VictimPlayerViewRotation, ref m_VictimPlayerViewRotation);
			m_AttackerPlayerHandle = other.AttackerPlayerHandle;
			Helper.Set<Vec3f, Vec3fInternal>(other.AttackerPlayerPosition, ref m_AttackerPlayerPosition);
			Helper.Set<Quat, QuatInternal>(other.AttackerPlayerViewRotation, ref m_AttackerPlayerViewRotation);
			Helper.Set(other.IsHitscanAttack, ref m_IsHitscanAttack);
			Helper.Set(other.HasLineOfSight, ref m_HasLineOfSight);
			Helper.Set(other.IsCriticalHit, ref m_IsCriticalHit);
			m_HitBoneId_DEPRECATED = other.HitBoneId_DEPRECATED;
			m_DamageTaken = other.DamageTaken;
			m_HealthRemaining = other.HealthRemaining;
			m_DamageSource = other.DamageSource;
			m_DamageType = other.DamageType;
			m_DamageResult = other.DamageResult;
			Helper.Set<LogPlayerUseWeaponData, LogPlayerUseWeaponDataInternal>(other.PlayerUseWeaponData, ref m_PlayerUseWeaponData);
			m_TimeSincePlayerUseWeaponMs = other.TimeSincePlayerUseWeaponMs;
			Helper.Set<Vec3f, Vec3fInternal>(other.DamagePosition, ref m_DamagePosition);
			Helper.Set<Vec3f, Vec3fInternal>(other.AttackerPlayerViewPosition, ref m_AttackerPlayerViewPosition);
		}

		public void Dispose()
		{
			Helper.Dispose(ref m_VictimPlayerPosition);
			Helper.Dispose(ref m_VictimPlayerViewRotation);
			Helper.Dispose(ref m_AttackerPlayerPosition);
			Helper.Dispose(ref m_AttackerPlayerViewRotation);
			Helper.Dispose(ref m_PlayerUseWeaponData);
			Helper.Dispose(ref m_DamagePosition);
			Helper.Dispose(ref m_AttackerPlayerViewPosition);
		}
	}
}
