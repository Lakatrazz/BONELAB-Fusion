// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;

namespace Epic.OnlineServices
{
	public sealed partial class Common
	{
		/// <summary>
		/// A character buffer of this size is large enough to fit a successful output of <see cref="EpicAccountId.ToString" />. This length does not include the <see langword="null" />-terminator.
		/// The EpicAccountId data structure is opaque in nature and no assumptions of its structure should be inferred
		/// </summary>
		public const int EPICACCOUNTID_MAX_LENGTH = 32;
		/// <summary>
		/// An invalid notification ID
		/// </summary>
		public const ulong INVALID_NOTIFICATIONID = ((ulong)0);
		/// <summary>
		/// A macro to identify an unknown integrated platform.
		/// </summary>
		public static readonly Utf8String IPT_UNKNOWN = (Utf8String)null;
		/// <summary>
		/// Epic online platform
		/// </summary>
		public const int OPT_EPIC = 100;
		/// <summary>
		/// Unknown online platform
		/// </summary>
		public const int OPT_UNKNOWN = 0;
		/// <summary>
		/// A character buffer of this size is large enough to fit a successful output of <see cref="ProductUserId.ToString" />. This length does not include the <see langword="null" />-terminator.
		/// </summary>
		public const int PRODUCTUSERID_MAX_LENGTH = 32;

		/// <summary>
		/// Encode a byte array into hex encoded <see cref="Utf8String" />
		/// </summary>
		/// <returns>
		/// An <see cref="Result" /> that indicates whether the byte array was converted and copied into the OutBuffer.
		/// <see cref="Result.Success" /> if the encoding was successful and passed out in OutBuffer
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> on invalid length for any of the parameters
		/// <see cref="Result.LimitExceeded" /> - The OutBuffer is not large enough to receive the encoding. InOutBufferLength contains the required minimum length to perform the operation successfully.
		/// </returns>
		public static Result ToString(ArraySegment<byte> byteArray, out Utf8String outBuffer)
		{
			var byteArrayPointer = IntPtr.Zero;
			uint length;
			Helper.Set(byteArray, ref byteArrayPointer, out length);

			uint inOutBufferLength = 1024;
			var outBufferPointer = Helper.AddAllocation(inOutBufferLength);

			var callResult = Bindings.EOS_ByteArray_ToString(byteArrayPointer, length, outBufferPointer, ref inOutBufferLength);

			Helper.Dispose(ref byteArrayPointer);

			Helper.Get(outBufferPointer, out outBuffer);
			Helper.Dispose(ref outBufferPointer);

			return callResult;
		}
		public static Utf8String ToString(ArraySegment<byte> byteArray)
		{
			Utf8String callResult;
			ToString(byteArray, out callResult);
			return callResult;
		}

		/// <summary>
		/// Returns whether a result is to be considered the final result, or <see langword="false" /> if the callback that returned this result
		/// will be called again either after some time or from another action.
		/// </summary>
		/// <param name="result">
		/// The result to check against being a final result for an operation
		/// </param>
		/// <returns>
		/// True if this result means the operation is complete, <see langword="false" /> otherwise
		/// </returns>
		public static bool IsOperationComplete(Result result)
		{
			var callResult = Bindings.EOS_EResult_IsOperationComplete(result);

			bool callResultReturn;
			Helper.Get(callResult, out callResultReturn);
			return callResultReturn;
		}

		/// <summary>
		/// Returns a <see cref="Utf8String" /> representation of an <see cref="Result" />.
		/// The return value is never <see langword="null" />.
		/// The return value must not be freed.
		/// 
		/// Example: <see cref="ToString" />(<see cref="Result.Success" />) returns "EOS_Success"
		/// </summary>
		public static Utf8String ToString(Result result)
		{
			var callResult = Bindings.EOS_EResult_ToString(result);

			Utf8String callResultReturn;
			Helper.Get(callResult, out callResultReturn);
			return callResultReturn;
		}
	}
}
